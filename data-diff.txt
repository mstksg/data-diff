-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Derivable diffing on arbitrary datatypes using GHC Generics
--   
--   Please see the README on Github at
--   <a>https://github.com/mstksg/data-diff#readme</a>
@package data-diff
@version 0.1.0.0

module Data.Diff

-- | Diffable types
--   
--   <pre>
--   <a>uncurry</a> <a>diff</a> . <a>undiff</a> = <a>id</a>
--   <a>undiff</a> . <a>uncurry</a> <a>diff</a> = <a>id</a>
--   <a>patch</a> (<a>diff</a> x y) x = <a>Just</a> y
--   </pre>
class (Eq a, Patch (Edit a)) => Diff a where {
    type family Edit a;
    type Edit a = GPatch a;
}

-- | Generate a patch between two values, that can be used to transform one
--   value into the other
diff :: Diff a => a -> a -> Edit a

-- | Apply a patch to a value
patch :: Diff a => Edit a -> a -> Maybe a

-- | Deconstruct a patch to recover the original value used to create it,
--   and the application of the patch to that original value
undiff :: Diff a => Edit a -> (a, a)

-- | Generate a patch between two values, that can be used to transform one
--   value into the other
diff :: (Diff a, DefaultDiff (Edit a) a) => a -> a -> Edit a

-- | Apply a patch to a value
patch :: (Diff a, DefaultDiff (Edit a) a) => Edit a -> a -> Maybe a

-- | Deconstruct a patch to recover the original value used to create it,
--   and the application of the patch to that original value
undiff :: (Diff a, DefaultDiff (Edit a) a) => Edit a -> (a, a)
class Patch a

-- | <a>Level</a> of patch
patchLevel :: Patch a => a -> DiffLevel

-- | Left-biased parallel merge of two patches
--   
--   Returns <a>Nothing</a> if patches come from incompatible sources
--   
--   Returns <a>True</a> if conflict occurred (and was resolved)
mergePatch :: Patch a => a -> a -> MergeResult a

-- | <a>Level</a> of patch
patchLevel :: (Patch a, Generic a, Every (Every Patch) (Code a)) => a -> DiffLevel

-- | Left-biased parallel merge of two patches
--   
--   Returns <a>Nothing</a> if patches come from incompatible sources
--   
--   Returns <a>True</a> if conflict occurred (and was resolved)
mergePatch :: (Patch a, IsProductType a as, Every Patch as) => a -> a -> MergeResult a

-- | Data type representing a "percentage difference"
data DiffLevel
DL :: Double -> Double -> DiffLevel
[dlAmt] :: DiffLevel -> Double
[dlTot] :: DiffLevel -> Double

-- | Result of a merge
data MergeResult a

-- | Incompatible sources
Incompatible :: MergeResult a

-- | Conflicts, throwing away info
Conflict :: a -> MergeResult a

-- | All conflicts resolved
NoConflict :: a -> MergeResult a

-- | Left-biased merge of two diffable values.
merge :: Diff a => a -> a -> a -> MergeResult a

-- | Merge all <a>DiffLevel</a> in a <a>Foldable</a> container, treating
--   them all as equally weighted.
catLevels :: Foldable f => f DiffLevel -> DiffLevel

-- | Rescale <a>DiffLevel</a> to be out of a given total.
--   
--   TODO: what about 0?
normDL :: Double -> DiffLevel -> DiffLevel

-- | Calculate percent difference.
--   
--   TODO: What about 0?
dlPercent :: DiffLevel -> Double

-- | How different two items are, as a percentage
percentDiff :: Diff a => a -> a -> Double

-- | <a>DiffLevel</a> of a <a>Prod</a> of <a>Edit</a>s
prodPatchLevel :: forall as. Every Diff as => Prod Edit' as -> DiffLevel

-- | Get <a>DiffLevel</a> between two items
compareDiff :: Diff a => a -> a -> DiffLevel
class DefaultDiff p a
defaultDiff :: DefaultDiff p a => a -> a -> p
defaultPatch :: DefaultDiff p a => p -> a -> Maybe a
defaultUndiff :: DefaultDiff p a => p -> (a, a)

-- | Newtype used to get around partial application of type families
newtype Edit' a
Edit' :: Edit a -> Edit' a
[getEdit'] :: Edit' a -> Edit a

-- | <a>diff'</a> lifted to <a>Edit'</a>
diff' :: Diff a => a -> a -> Edit' a

-- | <a>patch'</a> lifted to <a>Edit'</a>
patch' :: Diff a => Edit' a -> a -> Maybe a

-- | <a>undiff'</a> lifted to <a>Edit'</a>
undiff' :: Diff a => Edit' a -> (a, a)

-- | Patch type that treats all changes as total differences
data Swap a
NoChange :: a -> Swap a
Replace :: a -> a -> Swap a

-- | <a>diff</a> for all instances of <a>Eq</a>
eqDiff :: Eq a => a -> a -> Swap a

-- | <a>patch</a> for <a>Swap</a>
eqPatch :: Swap a -> a -> Maybe a

-- | Newtype wrapper that gives an automatic <a>Diff</a> instance that
--   treats all changes as total differences.
newtype EqDiff a
EqDiff :: a -> EqDiff a
[getEqDiff] :: EqDiff a -> a

-- | <a>patchLevel</a> written to work for any types deriving
--   <a>Generic</a>.
gpatchLevel :: forall a ass. (Generic a, Code a ~ ass, Every (Every Patch) ass) => a -> DiffLevel

-- | <a>mergePatch</a> written to work for any <b>product types</b>
--   deriving <a>Generic</a>.
gmergePatch :: forall a as. (IsProductType a as, Every Patch as) => a -> a -> MergeResult a
listDiff :: forall p a. (KnownNat p, Diff a) => [a] -> [a] -> SeqPatchAt p a
listPatch :: Eq a => SeqPatchAt p a -> [a] -> Maybe [a]
newtype SeqPatchAt (p :: Nat) a
SPA :: [Diff a] -> SeqPatchAt a
[getSPA] :: SeqPatchAt a -> [Diff a]
type SeqPatch = SeqPatchAt 50
seqDiff :: (KnownNat p, Diff a) => (t -> [a]) -> t -> t -> SeqPatchAt p a
seqPatch :: Eq a => (t -> [a]) -> ([a] -> t) -> SeqPatchAt p a -> t -> Maybe t

-- | Generic patch type for any types deriving <a>Generic</a>.
newtype GPatch a
GP :: SumDiff Tuple (Prod Edit') (Code a) -> GPatch a
[getGP] :: GPatch a -> SumDiff Tuple (Prod Edit') (Code a)

-- | <a>diff</a> intented to work for all instances of <a>Generic</a>. Will
--   treat constructor changes as partial differences if they both contain
--   the same type of values.
gdiff :: forall a. (Generic a, Every (Every Diff) (Code a), Every Typeable (Code a)) => a -> a -> GPatch a

-- | <a>diff</a> intented to work for all instances of <a>Generic</a>.
--   Differs from <a>gdiff</a> in that it treats constructor changes as
--   total differences, even if they both contain the same type of values.
gdiff' :: forall a. (Generic a, Every (Every Diff) (Code a)) => a -> a -> GPatch a

-- | <a>patch</a> intented to work for all instances of <a>Generic</a>.
gpatch :: forall a. (Generic a, Every (Every Diff) (Code a)) => GPatch a -> a -> Maybe a

-- | <a>undiff</a> intended to work for all instances of <a>Generic</a>.
gundiff :: forall a. (Generic a, Every (Every Diff) (Code a)) => GPatch a -> (a, a)

-- | Generic patch type for all product types that are instances of
--   <a>Generic</a>.
data GPatchProd a
GPP :: Prod Edit' as -> GPatchProd a
[getGPP] :: GPatchProd a -> Prod Edit' as

-- | <a>diff</a> intended to work for all product types that are instances
--   of <a>Generic</a>.
gdiffProd :: forall a as. (IsProductType a as, Every Diff as) => a -> a -> GPatchProd a

-- | <a>patch</a> intended to work for all product types that are instances
--   of <a>Generic</a>.
gpatchProd :: forall a as. (IsProductType a as, Every Diff as) => GPatchProd a -> a -> Maybe a

-- | <a>undiff</a> intended to work for all product types that are
--   instances of <a>Generic</a>.
gundiffProd :: forall a as. (IsProductType a as, Every Diff as) => GPatchProd a -> (a, a)
data SumDiff :: (k -> Type) -> (k -> Type) -> [k] -> Type
[SD] :: (Index as :&: CtrDiff f g as) a -> SumDiff f g as
data CtrDiff :: (k -> Type) -> (k -> Type) -> [k] -> k -> Type
[CDEdit] :: g a -> CtrDiff f g as a
[CDName] :: (Index as :&: g) a -> CtrDiff f g as a
[CDDiff] :: f a -> (Index as :&: f) b -> CtrDiff f g as a
data ValDiff a
VDDel :: a -> ValDiff a
VDIns :: a -> ValDiff a
VDMod :: (Edit a) -> ValDiff a
newtype MapDiff m a
MD :: m (ValDiff a) -> MapDiff m a
[getMD] :: MapDiff m a -> m (ValDiff a)
